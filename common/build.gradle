plugins {
    id "com.github.johnrengelman.shadow" version "8.1.1"
    id "me.hypherionmc.modutils.modpublisher" version "1.0.17"
}

remapJar {
    if (isMCPJar && protocol <= 2) { // MC a1.1.2_01 and below
        prodNamespace "searge"
    } else {
        prodNamespace(!isModern ? "mcp" : "mojmap")
    }
}

configurations {
    shadeOnly
    shade
    runtime
    implementation.extendsFrom shade
    runtimeOnly.extendsFrom
}

dependencies {
    // Legacy Dependencies, based on Protocol Version
    if (isLegacy) {
        if (protocol <= 61) { // MC 1.5.2 and below
            shade('com.google.code.gson:gson:2.2.2')
        }
    }

    // Java-Specific Dependencies
    shade("com.kohlschutter.junixsocket:junixsocket-common:${isLegacy ? "2.4.0" : "2.6.2"}")
    shade("com.kohlschutter.junixsocket:junixsocket-native-common:${isLegacy ? "2.4.0" : "2.6.2"}")

    // Annotations
    implementation "com.google.code.findbugs:jsr305:3.0.2"
    implementation "com.github.spotbugs:spotbugs-annotations:4.7.3"

    // LeniReflect
    shade("net.lenni0451:Reflect:${reflect_version}")

    // DiscordIPC (Originally by jagrosh)
    shade("io.github.CDAGaming:DiscordIPC:${ipc_version}")
    // StarScript (Used for Placeholder Expressions)
    shade("io.github.CDAGaming:starscript:${starscript_version + (isLegacy ? "-legacy" : "")}")
    shade("io.github.classgraph:classgraph:${classgraph_version}")
    // SLF4J Dependencies (If below 1.17)
    if (isLegacy || protocol < 755) {
        shade('org.slf4j:slf4j-api:1.7.36')
        if (isLegacy) {
            shade('org.slf4j:slf4j-jdk14:1.7.36')
        } else {
            runtime('org.slf4j:slf4j-jdk14:1.7.36')

            // 17w15a (1.12) and higher use 2.x's full releases of Log4j
            // while anything below that uses (Or should be using) the *fixed* version of 2.0-beta9
            def log4j_version = protocol >= 321 ? "2.0" : "2.0-beta9"
            shadeOnly("org.apache.logging.log4j:log4j-slf4j-impl:${log4j_version}") {
                exclude group: 'org.apache.logging.log4j', module: "log4j-api"
                exclude group: 'org.apache.logging.log4j', module: "log4j-core"
            }
        }
    }

    // Additional Integrations
    if (!isLegacy) {
        // Moon Config (Used for HypherConverter)
        shade("me.hypherionmc.moon-config:core:${moonconf_version}")
        shade("me.hypherionmc.moon-config:toml:${moonconf_version}")
    }
}

// JSON to LANG Conversion Setup (Below 18w02a, 1.13)
def mainResources = "$projectDir/src/main/resources"
def generatedResources = "$buildDir/generated-resources"

if (isLegacy || protocol < 353) {
    sourceSets {
        main {
            output.dir(generatedResources, builtBy: 'generateMyResources')
        }
    }
}

jar {
    from sourceSets.main.output
}

shadowJar {
    configurations = [project.configurations.shade, project.configurations.shadeOnly]

    // Meta Exclusions
    exclude '**/DEPENDENCIES*'
    exclude '**/LICENSE*'
    exclude '**/Log4J*'
    exclude 'META-INF/NOTICE*'
    exclude 'META-INF/versions/**'

    // JUnixSocket exclusions:
    // libs
    // discord doesn't support bsd or sun
    exclude 'lib/*BSD*/**'
    exclude 'lib/*Sun*/**'
    // we don't use junixsocket on windows
    exclude 'lib/*Window*/**'
    // include only arm on mac
    exclude 'lib/aarch64-Linux*/**'
    // doesn't support these architectures
    exclude 'lib/ppc*/**'
    exclude 'lib/risc*/**'
    exclude 'lib/s390x*/**'
    exclude 'lib/arm*/**'
    // metadata
    // discord doesn't support bsd or sun
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-*BSD*/**'
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-*Sun*/**'
    // we don't use junixsocket on windows
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-*Window*/**'
    // include only arm on mac
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-aarch64-Linux*/**'
    // doesn't support these architectures
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-ppc*/**'
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-risc*/**'
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-s390x*/**'
    exclude 'META-INF/native-image/com.kohlschutter.junixsocket/junixsocket-native-arm*/**'

    // Package Relocations
    relocate 'net.lenni0451', 'external.net.lenni0451'
    relocate 'com.jagrosh', 'external.com.jagrosh'
    relocate 'org.meteordev', 'external.org.meteordev'
    relocate 'io.github.classgraph', 'external.io.github.classgraph'
    relocate 'nonapi.io.github.classgraph', 'external.nonapi.io.github.classgraph'
    if (protocol < 755) {
        relocate 'org.slf4j', 'external.org.slf4j'
        relocate 'org.apache.logging.slf4j', 'external.org.apache.logging.slf4j'
    }
    // Integration Relocations
    if (!isLegacy) {
        relocate 'me.hypherionmc', 'external.me.hypherionmc'
    }

    archiveClassifier.set('shadow-dev')
}

processResources {
    filesMatching("assets/${rootProject.name.toLowerCase()}/lang/**") { FileCopyDetails data ->
        def text = data.file.getText("UTF-8")
        if ((text == null || text.isEmpty()) || text == "{}") {
            exclude()
        }
    }
}
tasks.processResources.outputs.upToDateWhen { false }

import groovy.io.FileType

import java.util.regex.Pattern

tasks.register('generateMyResources') {
    doFirst {
        def langDir = new File(mainResources, "/assets/${rootProject.name.toLowerCase()}/lang")
        def resultDir = new File(generatedResources, "/assets/${rootProject.name.toLowerCase()}/lang")
        langDir.mkdirs()
        resultDir.mkdirs()
        langDir.eachFileRecurse(FileType.FILES) { file ->
            if (file.path.endsWith(".json")) {
                def contents = "#PARSE_ESCAPES\n"
                def replacements = 0
                System.out.println("Converting json to lang: " + file.path)
                // Logic from TranslationUtils#getTranslationMap
                // Does not include the escape replacements, as those are done later
                for (currentString in file.getText("UTF-8").readLines()) {
                    currentString = currentString.trim()
                    if (!currentString.startsWith("#") && !currentString.startsWith("[{}]") && currentString.contains(":")) {
                        final String[] splitTranslation = currentString.split(":", 2)
                        String str1 = splitTranslation[0].substring(1, splitTranslation[0].length() - 1).trim()
                        String str2 = splitTranslation[1].substring(2, splitTranslation[1].length() - (splitTranslation[1].endsWith(",") ? 2 : 1)).trim()
                        contents += "${str1}=${str2}\n"
                        replacements++
                    }
                }
                // Only proceed if we actually performed any replacements
                if (replacements > 0) {
                    def resultName = file.name.replace(".json", ".lang")
                    if (protocol <= 210) {
                        // On 1.10.2 (Pack Format 2 or below) or Legacy MC
                        // Adjust name format from xx_xx to xx_XX
                        var matches = Pattern.compile("_.+?\\.").matcher(resultName);
                        while (matches.find()) {
                            def match = matches.group()
                            resultName = resultName.replace(match, match.toUpperCase())
                        }
                    }
                    def resultFile = new File(resultDir, resultName)
                    resultFile.createNewFile()
                    System.out.println("Outputting to: " + resultFile.path)
                    resultFile.setText(contents.replaceAll("(?s)\\\\(.)", '$1'), "UTF-8")
                } else {
                    System.out.println("Skipping " + file.path + " (No content found)")
                }
            }
        }
    }
}

// Setup Name Schema for Uploading
def archive_name = "${mod_name}"
def targetFile = file("$rootDir/build/libs/${fileFormat}.jar")
if (!targetFile.exists() && isJarMod) {
    // Fallback to an alternative Sub-Project Output when in a Jar Mod configuration and the target file isn't there
    targetFile = file("$rootDir/${fmlName}/build/libs/${fileFormat}-${fmlName}.jar")
}

// Setup Game Versions to upload for
def uploadVersions = [mc_version.toString()]
for (String v : additional_mc_versions.split(',')) {
    if (v) {
        uploadVersions.add(v)
    }
}

// Setup Game Loaders to upload for
def uploadLoaders = enabled_platforms.split(',').toList()
for (String v : additional_loaders.split(',')) {
    if (v) {
        uploadLoaders.add(v)
    }
}

publisher {
    apiKeys {
        curseforge = System.getenv("CF_APIKEY")
        modrinth = System.getenv("MODRINTH_TOKEN")
    }

    debug = false
    curseID = "297038"
    modrinthID = "DFqQfIBR"
    versionType = "${deploymentType}".toLowerCase()
    changelog = file("$rootDir/Changes.md").text
    version = "v${versionFormat}".replaceAll("\\s", "").toLowerCase() // Modrinth Only
    displayName = "${archive_name} v${versionId}${versionLabel.isEmpty() ? "" : " ${versionLabel}"} (${mcVersionLabel})"
    gameVersions = uploadVersions
    loaders = uploadLoaders
    curseEnvironment = "client"
    artifact = targetFile
}
