plugins {
    id "com.github.johnrengelman.shadow" version "7.1.2"
}

configurations {
    shadeOnly
    shade
    implementation.extendsFrom shade
}

dependencies {
    modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
    // Java-Specific Dependencies
    if (targetCompatibility.isJava8Compatible()) {
        shade('com.kohlschutter.junixsocket:junixsocket-common:2.5.1')
        shade('com.kohlschutter.junixsocket:junixsocket-native-common:2.5.1')
    } else {
        shade('com.kohlschutter.junixsocket:junixsocket-common:2.4.0')
        shade('com.kohlschutter.junixsocket:junixsocket-native-common:2.4.0')
    }
    implementation "com.google.code.findbugs:jsr305:3.0.2"

    // DiscordIPC (Originally by jagrosh)
    shade("io.github.CDAGaming:DiscordIPC:${rootProject.ipc_version}")
    // SLF4J Dependencies
    shade('org.slf4j:slf4j-api:1.7.36')
    runtimeOnly('org.slf4j:slf4j-jdk14:1.7.36')
    shadeOnly('org.apache.logging.log4j:log4j-slf4j-impl:2.0') {
        exclude group: 'org.apache.logging.log4j', module: "log4j-api"
        exclude group: 'org.apache.logging.log4j', module: "log4j-core"
    }

    // Additional Integrations
    shade("me.hypherionmc.moon-config:core:${moonconf_ver}")
    shade("me.hypherionmc.moon-config:toml:${moonconf_ver}")
}

architectury {
    injectInjectables = false
    common(rootProject.enabled_platforms.split(","))
}

loom {
    accessWidenerPath = file("$rootDir/src/main/resources/craftpresence.accesswidener")
}

def mainResources = "$rootDir/src/main/resources"
def generatedResources = "$buildDir/generated-resources"

// ignore this jank, it's so I don't have to move the src folder, as that creates unnecessary git conflicts
sourceSets {
    main {
        java {
            java {
                srcDir "$rootDir/src/main/java"
            }
            resources {
                srcDir "$rootDir/src/main/resources"
            }
        }
        output.dir(generatedResources, builtBy: 'generateMyResources')
    }
}

jar {
    from sourceSets.main.output
}

shadowJar {
    configurations = [project.configurations.shade, project.configurations.shadeOnly]

    // Meta Exclusions
    exclude '**/DEPENDENCIES*'
    exclude '**/LICENSE*'
    exclude '**/Log4J*'
    exclude 'META-INF/NOTICE*'
    exclude 'META-INF/versions/**'
    // Package Relocations
    relocate 'com.jagrosh', 'external.com.jagrosh'
    relocate 'org.slf4j', 'external.org.slf4j'
    relocate 'org.apache.logging.slf4j', 'external.org.apache.logging.slf4j'
    // Integration Relocations
    relocate 'me.hypherionmc', 'external.me.hypherionmc'

    archiveClassifier.set('shadow-dev')
}

import groovy.io.FileType
import org.apache.tools.ant.filters.ReplaceTokens

import java.util.regex.Pattern

task generateMyResources {
    doFirst {
        def langDir = new File(mainResources, "/assets/$rootProject.name/lang")
        def resultDir = new File(generatedResources, "/assets/$rootProject.name/lang")
        langDir.mkdirs()
        resultDir.mkdirs()
        langDir.eachFileRecurse(FileType.FILES) { file ->
            if (file.path.endsWith(".json")) {
                def contents = "#PARSE_ESCAPES\n"
                System.out.println("Converting json to lang: " + file.path)
                // Logic from TranslationUtils#getTranslationMap
                // Does not include the escape replacements, as those are done later
                for (currentString in file.text.readLines()) {
                    currentString = currentString.trim()
                    if (!currentString.startsWith("#") && !currentString.startsWith("[{}]") && currentString.contains(":")) {
                        final String[] splitTranslation = currentString.split(":", 2)
                        String str1 = splitTranslation[0].substring(1, splitTranslation[0].length() - 1).trim()
                        String str2 = splitTranslation[1].substring(2, splitTranslation[1].length() - (splitTranslation[1].endsWith(",") ? 2 : 1)).trim()
                        contents += "${str1}=${str2}\n"
                    }
                }
                def resultName = file.name.replace(".json", ".lang")
                if ("${rootProject.mc_protocol}".toInteger() <= 210) {
                    // On 1.10.2 (Pack Format 2 or below) or Legacy MC
                    // Adjust name format from xx_xx to xx_XX
                    resultName = Pattern.compile("_.+?\\.").matcher(resultName).replaceAll(m -> m.group().toUpperCase())
                }
                def resultFile = new File(resultDir, resultName)
                resultFile.createNewFile()
                System.out.println("Outputting to: " + resultFile.path)
                resultFile.text = contents.replaceAll("(?s)\\\\(.)", '$1')
            }
        }
    }
}

def copyDir = "$compileJava.temporaryDir/replaced"
task processSource(type: Sync) {
    // This will ensure that this task is redone when the properties change.
    inputs.property "modName", "${mod_name}"
    inputs.property "versionId", "${versionId}"
    inputs.property "versionType", "${deploymentType}"
    inputs.property "versionLabel", "${versionLabel}"
    inputs.property "mcVersion", "${mc_version}"
    inputs.property "mcProtocol", "${mc_protocol}"

    from sourceSets.main.java
    filter(ReplaceTokens, tokens: [
            MOD_NAME    : mod_name,
            VERSION_ID  : "${baseVersionLabel}".toString(),
            VERSION_TYPE: deploymentType,
            MC_VERSION  : mc_version,
            MC_PROTOCOL : mc_protocol
    ])
    into copyDir
}

compileJava {
    source = processSource.outputs
}