import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.internal.jvm.Jvm

import java.nio.file.Files

plugins {
    id 'xyz.wagyourtail.unimined' version '1.0.0-SNAPSHOT' apply false
    id "com.diffplug.gradle.spotless" version "6.18.0" apply false
    id "io.github.pacifistmc.forgix" version "1.2.6"
}

def ext_mcVersionLabel = rootProject.hasProperty("mc_version_extra") ? "${mc_version_extra}" : "${mc_version}"
def ext_versionLabel = "${rootProject.versionLabel.equalsIgnoreCase("release") ? "" : "${rootProject.versionLabel}"}"

def ext_versionInfoLabel = "${ext_versionLabel.isEmpty() ? "" : "-${ext_versionLabel}"}"
def ext_baseVersionLabel = "${rootProject.versionId + ext_versionInfoLabel.replaceAll("\\s", ".")}".toLowerCase()
def ext_classPath = "${rootProject.group}".replace(".", "/") + "/${mod_name}".toLowerCase()

def ext_versionFormat = "${ext_baseVersionLabel + "+" + ext_mcVersionLabel}"
def ext_fileFormat = "${rootProject.mod_name}-${ext_versionFormat}"

int ext_protocol = "${mc_protocol}".toInteger()
boolean ext_isLegacy = "${isLegacy}".toBoolean()
boolean ext_isJarMod = "${isJarMod}".toBoolean()
boolean ext_isModern = !ext_isLegacy && ext_protocol >= 498
boolean ext_isMCPJar = ext_isJarMod && mc_mappings_type == "mcp"

def ext_fmlName = ext_isJarMod ? "modloader" : "forge"

// Only apply ATs to forge on non-legacy builds, or on Legacy Protocols above 1.5
// due to the way Forge requires core-mods for lower version usage
def ext_accessWidenerFile = file("$rootDir/fabric/src/main/resources/craftpresence.accesswidener")
def ext_canUseATs = ext_accessWidenerFile.exists() && (!ext_isLegacy || ext_protocol > 60)

subprojects {
    apply plugin: 'java'
    apply plugin: 'xyz.wagyourtail.unimined'
    apply plugin: "com.diffplug.spotless"

    ext {
        versionInfoLabel = "${ext_versionInfoLabel}"
        baseVersionLabel = "${ext_baseVersionLabel}"
        classPath = "${ext_classPath}"
        versionFormat = "${ext_versionFormat}"
        fileFormat = "${ext_fileFormat}"
        protocol = ext_protocol
        isLegacy = ext_isLegacy
        isJarMod = ext_isJarMod
        isModern = ext_isModern
        isMCPJar = ext_isMCPJar
        fmlName = "${ext_fmlName}"
        accessWidenerFile = ext_accessWidenerFile
        canUseATs = ext_canUseATs
        mcVersionLabel = "${ext_mcVersionLabel}"
        versionLabel = "${ext_versionLabel}"
    }

    spotless {
        java {
            licenseHeaderFile(rootProject.file("HEADER"))
        }
    }

    version = "${versionFormat}"
    group = rootProject.group
    archivesBaseName = "${mod_name}"

    Jvm currentJvm = Jvm.current()
    JavaVersion sourceVersion = currentJvm.getJavaVersion()
    JavaVersion targetVersion = JavaVersion.VERSION_1_8

    boolean modern_source_support = sourceVersion.isJava9Compatible()
    boolean modern_target_support = targetVersion.isJava9Compatible()

    if (!modern_source_support) {
        sourceCompatibility = sourceVersion
        targetCompatibility = targetVersion
    }

    java {
        withSourcesJar()
    }

    repositories {
        maven {
            name = "Forge"
            url = "https://maven.minecraftforge.net/"
            metadataSources {
                artifact()
                if (!isLegacy) {
                    mavenPom()
                }
            }
        }
        mavenCentral()
        maven {
            name = 'Fabric'
            url = "https://maven.fabricmc.net/"
        }
        maven {
            name = "Legacy Fabric"
            url = "https://maven.legacyfabric.net/"
        }
        // WagYourTail Mavens
        maven { url "https://maven.wagyourtail.xyz/releases" }
        maven { url "https://maven.wagyourtail.xyz/snapshots" }
        // OSS Mavens
        maven { url "https://s01.oss.sonatype.org/content/repositories/releases" }
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots" }
        // HypherionMC Mavens
        maven { url "https://maven.firstdarkdev.xyz/releases" }
        maven { url "https://maven.firstdarkdev.xyz/snapshots" }
        // Mod Integration Mavens
        maven {
            name = "CurseForge"
            url = "https://cursemaven.com"
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
        maven {
            name = 'TerraformersMC'
            url = 'https://maven.terraformersmc.com/releases/'
        }
    }

    // debug, puts some things in build/unimined instead of ~/.gradle/caches/unimined
    unimined.useGlobalCache = false

    unimined.minecraft(sourceSets.main) {
        def mc_version = "${rootProject.mc_version}"
        def mc_mapping_type = "${rootProject.mc_mappings_type}"

        side(isJarMod ? "client" : "combined")
        version mc_version

        switch (path) {
            case ":common":
                if (!isJarMod) {
                    def fabricData = {
                        if (accessWidenerFile.exists()) {
                            accessWidener accessWidenerFile
                        }
                        loader rootProject.fabric_loader_version
                        customIntermediaries = true
                    }
                    if (ext_isModern) {
                        fabric fabricData
                    } else {
                        legacyFabric fabricData
                    }
                }
                break
            case ":fabric":
                def fabricData = {
                    if (accessWidenerFile.exists()) {
                        accessWidener accessWidenerFile
                    }
                    loader rootProject.fabric_loader_version
                    if (isJarMod) {
                        prodNamespace "official"
                        devMappings = null
                    }
                    customIntermediaries = true
                }
                if (ext_isModern) {
                    fabric fabricData
                } else {
                    legacyFabric fabricData
                }
                break
            case ":forge":
                if (!isJarMod) {
                    forge {
                        if (canUseATs) {
                            accessTransformer aw2at(accessWidenerFile)
                        }
                        forge rootProject.forge_version
                        customSearge = (mc_mapping_type != "mojmap")
                    }
                    // Note: Required for proper mixin remaps
                    mods {
                        modImplementation {
                            mixinRemap("UNIMINED")
                        }
                    }
                }
                break
            case ":modloader":
                jarMod {}
                break
        }

        mappings {
            def mc_mappings = "${rootProject.mc_mappings}"
            switch (mc_mapping_type) {
                case "mcp":
                    if (!isJarMod) {
                        searge()
                    }
                    mcp(isJarMod ? "legacy" : "stable", mc_mappings) {
                        if (!isJarMod) {
                            clearOutputs()
                            outputs("mcp", true) { ["intermediary"] }
                        }
                    }
                    break
                case "forgeMCP":
                    forgeBuiltinMCP("${rootProject.forge_version}") {
                        clearContains()
                        clearOutputs()
                        contains({ _, t ->
                            !t.contains("MCP")
                        }) {
                            onlyExistingSrc()
                            outputs("searge", false) { ["official"] }
                        }
                        contains({ _, t ->
                            t.contains("MCP")
                        }) {
                            outputs("mcp", true) { ["intermediary"] }
                            sourceNamespace("searge")
                        }
                    }
                    officialMappingsFromJar {
                        clearContains()
                        clearOutputs()
                        outputs("official", false) { [] }
                    }
                    break
                case "retroMCP":
                    retroMCP()
                    break
                case "yarn":
                    yarn(mc_mappings)
                    break
                case "mojmap":
                    mojmap() {
                        skipIfNotIn("intermediary")
                    }
                    break
                case "parchment":
                    parchment(mc_version, mc_mappings)
                    break
                default:
                    throw new GradleException("Unknown or Unsupported Mappings version")
            }

            // Only use Intermediaries on Versions that support it
            def usingIntermediary = (isLegacy && protocol >= 39) || !isLegacy
            if (usingIntermediary) {
                if (ext_isModern) {
                    intermediary()
                } else {
                    legacyIntermediary()
                }
            }

            // ability to add custom mappings
            def target = !ext_isModern ? "mcp" : "mojmap"
            stub.withMappings(["searge", target]) {
                c("ModLoader", "net/minecraft/src/ModLoader", "net/minecraft/src/ModLoader")
                c("BaseMod", "net/minecraft/src/BaseMod", "net/minecraft/src/BaseMod")
            }

            if (isMCPJar) {
                if (protocol <= 2) { // MC a1.1.2_01 and below
                    devNamespace "searge"
                } else {
                    devFallbackNamespace "searge"
                }
            } else if (usingIntermediary) {
                devFallbackNamespace "intermediary"
            }
        }

        minecraftRemapper.config {
            // most mcp mappings (except older format) dont include field desc
            ignoreFieldDesc(true)
            // this also fixes some issues with them, as it tells tiny remapper to try harder to resolve conflicts
            ignoreConflicts(true)
        }
    }

    dependencies {
        if (!modern_target_support) {
            // If we are targeting a release below Java 9,
            // work around JDK-8206937 by providing a shim for inaccessible classes.
            compileOnly("me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0")
        }
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.encoding = "UTF-8"

        // The Minecraft launcher currently installs Java 8 for users, so your mod probably wants to target Java 8 too
        // JDK 9 introduced a new way of specifying this that will make sure no newer classes or methods are used.
        // We'll use that if it's available, but otherwise we'll use the older option.
        if (modern_source_support) {
            it.options.release.set(Integer.parseInt(targetVersion.getMajorVersion()))
        }
    }

    gradle.projectsEvaluated {
        tasks.withType(Javadoc).configureEach {
            it.options.encoding = "UTF-8"

            exclude "**/*Gui.java"
            exclude "${classPath}/config/**"
            exclude "${classPath}/integrations/**"
        }
    }

    def copyDir = "$compileJava.temporaryDir/replaced"
    tasks.register('processSource', Sync) {
        // This will ensure that this task is redone when the properties change.
        inputs.property "modName", "${mod_name}"
        inputs.property "versionId", "${versionId}"
        inputs.property "versionType", "${deploymentType}"
        inputs.property "versionLabel", "${versionLabel}"
        inputs.property "mcVersion", "${mcVersionLabel}"
        inputs.property "mcProtocol", "${mc_protocol}"
        inputs.property "isLegacy", "${isLegacy}"
        inputs.property "isDevState", "${isDevState}"
        inputs.property "isVerboseState", "${isVerboseState}"

        from sourceSets.main.java
        filter(ReplaceTokens, tokens: [
                MOD_NAME    : "${mod_name}".toString(),
                VERSION_ID  : "${baseVersionLabel}".toString(),
                VERSION_TYPE: "${deploymentType}".toString(),
                MC_VERSION  : "${mcVersionLabel}".toString(),
                MC_PROTOCOL : "${mc_protocol}".toString(),
                IS_LEGACY   : "${isLegacy}".toString(),
                IS_DEV      : "${isDevState}".toString(),
                IS_VERBOSE  : "${isVerboseState}".toString()
        ])
        into copyDir
    }

    compileJava {
        source = processSource.outputs

        if (isLegacy) {
            doLast {
                getLogger().info("Processing source via RetroLambda...")
                if (sourceVersion >= JavaVersion.VERSION_12) {
                    getLogger().warn("WARNING: Only Java 11 and below are supported with RetroLambda processing.")
                }
                var retrolambaJar = new URL("https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/2.5.7/retrolambda-2.5.7.jar")
                var retrolambdaFile = new File("${rootProject.buildDir}/retrolambda/retrolambda.jar")
                if (!retrolambdaFile.exists()) {
                    retrolambdaFile.getParentFile().mkdirs()
                    try (InputStream is = retrolambaJar.openStream()) {
                        Files.copy(is, retrolambdaFile.toPath())
                    }
                }
                var classpath = project.sourceSets.main.runtimeClasspath
                var classpathString = classpath.files.collect { it.absolutePath }.join(File.pathSeparator)
                var javahome = currentJvm.getJavaHome().getAbsolutePath()
                var javaexe = javahome + File.separator + "bin" + File.separator + "java"
                if (System.getProperty("os.name").toLowerCase().contains("win") && !System.getProperty("os.name").toLowerCase().contains("darwin")) {
                    javaexe += ".exe"
                }
                var destDir = compileJava.destinationDirectory.getAsFile().getOrNull()
                var processBuilder = new ProcessBuilder(
                        javaexe,
                        "-Dretrolambda.inputDir=${destDir.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.classpath=${classpathString.replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.defaultMethods=true",
                        "-Dretrolambda.bytecodeVersion=51",
                        "-javaagent:${retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-jar",
                        retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ "),
                )
                var outputLog = new File("${rootProject.buildDir}/retrolambda/${project.path.replace(":", "_")}-output.log")
                processBuilder.redirectOutput(outputLog)
                processBuilder.redirectError(outputLog)
                var process = processBuilder.start()
                process.waitFor()
                if (process.exitValue() != 0) {
                    throw new GradleException("RetroLambda failed with exit code " + process.exitValue())
                } else {
                    getLogger().info("Source processing via RetroLambda completed successfully!")
                }
            }
        }
    }
}

forgix {
    group = rootProject.group
    mergedJarName = "${ext_fileFormat}.jar"
    outputDir = "build/libs"

    // Forge / ModLoader
    custom {
        projectName = "${ext_fmlName}"
        jarLocation = "build/libs/${ext_fileFormat}-${ext_fmlName}.jar"
    }

    fabric {
        jarLocation = "build/libs/${ext_fileFormat}-fabric.jar"
    }
}
