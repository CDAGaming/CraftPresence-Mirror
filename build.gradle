import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.internal.jvm.Jvm

import java.nio.file.Files

plugins {
    id 'xyz.wagyourtail.unimined' version '0.4.2-SNAPSHOT' apply false
    id "com.diffplug.gradle.spotless" version "6.16.0" apply false
    id "io.github.pacifistmc.forgix" version "1.2.6"
}

def ext_versionInfoLabel = "${rootProject.deploymentType.equalsIgnoreCase("release") ? "" : "-${rootProject.versionLabel}"}"
def ext_baseVersionLabel = "${rootProject.versionId + ext_versionInfoLabel.replaceAll("\\s", ".")}".toLowerCase()
def ext_classPath = "${rootProject.group}".replace(".", "/") + "/${mod_name}".toLowerCase()

def ext_versionFormat = "${ext_baseVersionLabel + "+" + mc_version}"
def ext_fileFormat = "${rootProject.mod_name}-${ext_versionFormat}"

int ext_protocol = "${mc_protocol}".toInteger()
boolean ext_isLegacy = "${isLegacy}".toBoolean()
boolean ext_isJarMod = "${isJarMod}".toBoolean()

subprojects {
    apply plugin: 'java'
    apply plugin: 'xyz.wagyourtail.unimined'
    apply plugin: "com.diffplug.spotless"

    ext {
        versionInfoLabel = "${ext_versionInfoLabel}"
        baseVersionLabel = "${ext_baseVersionLabel}"
        classPath = "${ext_classPath}"
        versionFormat = "${ext_versionFormat}"
        fileFormat = "${ext_fileFormat}"
        protocol = ext_protocol
        isLegacy = ext_isLegacy
        isJarMod = ext_isJarMod
    }

    spotless {
        java {
            licenseHeaderFile(rootProject.file("HEADER"))
        }
    }

    version = "${versionFormat}"
    group = rootProject.group
    archivesBaseName = "${mod_name}"

    Jvm currentJvm = Jvm.current();
    JavaVersion sourceVersion = currentJvm.getJavaVersion()
    JavaVersion targetVersion = JavaVersion.VERSION_1_8

    boolean modern_source_support = sourceVersion.isJava9Compatible()
    boolean modern_target_support = targetVersion.isJava9Compatible()

    if (!modern_source_support) {
        sourceCompatibility = sourceVersion
        targetCompatibility = targetVersion
    }

    java {
        withSourcesJar()
    }

    unimined {
        // debug, puts some things in build/unimined instead of ~/.gradle/caches/unimined
        // I recommend you leave this off until unimined is stable
        useGlobalCache = false
    }

    minecraft {
        if (isLegacy) {
            clientSourceSets = [sourceSets.main]
        }
        mcRemapper.tinyRemapperConf = {
            // most mcp mappings (except older format) dont include field desc
            ignoreFieldDesc(true)
            // this also fixes some issues with them, as it tells tiny remapper to try harder to resolve conflicts
            ignoreConflicts(true)
        }
    }

    remapJar {
        if (isJarMod) {
            setEnv("CLIENT")
        }
    }

    repositories {
        flatDir {
            dirs "$rootDir/libs"
        }
        mavenCentral()
        maven {
            name = "Forge"
            url = "https://maven.minecraftforge.net/"
            metadataSources {
                it.artifact()
            }
        }
        maven {
            name = 'Fabric'
            url = "https://maven.fabricmc.net/"
        }
        maven {
            name = "Legacy Fabric"
            url = "https://maven.legacyfabric.net/"
        }
        // OSS Mavens
        maven { url "https://s01.oss.sonatype.org/content/repositories/releases" }
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots" }
        // HypherionMC Mavens
        maven { url "https://maven.firstdarkdev.xyz/releases" }
        maven { url "https://maven.firstdarkdev.xyz/snapshots" }
        // Mod Integration Mavens
        maven {
            name = "CurseForge"
            url = "https://cursemaven.com"
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
        maven {
            name = 'TerraformersMC'
            url = 'https://maven.terraformersmc.com/releases/'
        }
        ivy {
            name = "ReplayMod"
            url = "https://minio.replaymod.com/replaymod/"
            patternLayout { artifact("[artifact]-[revision](-[classifier])(.[ext])") }
            metadataSources { it.artifact() }
            content { includeGroup("com.replaymod") }
        }
    }

    dependencies {
        minecraft "net.minecraft:minecraft:${rootProject.mc_version}"
        // If a Legacy Build or below 1.14.4, use MCP Data; otherwise use mojmaps
        if (isLegacy || protocol < 498) {
            if (isJarMod) {
                mappings "local_mod:mcp:${mc_mappings}@zip"
            } else if (!isLegacy) {
                if (protocol >= 340) {
                    mappings "de.oceanlabs.mcp:mcp_config:${rootProject.mc_version}@zip"
                } else {
                    mappings "de.oceanlabs.mcp:mcp:${rootProject.mc_version}:srg@zip"
                }
                mappings "de.oceanlabs.mcp:mcp_stable:${rootProject.mc_mappings}@zip"
            } else {
                mappings "net.minecraftforge:forge:${rootProject.mc_version}-${rootProject.forge_version}:src@zip"
            }
        } else {
            mappings "net.minecraft:minecraft:${rootProject.mc_version}:client-mappings"
        }

        // Only use Intermediaries on Versions that support it
        if ((isLegacy && protocol >= 39) || !isLegacy) {
            mappings "${rootProject.fabric_group}:intermediary:${rootProject.mc_version}:v2"
        }

        if (!modern_target_support) {
            // If we are targeting a release below Java 9,
            // work around JDK-8206937 by providing a shim for inaccessible classes.
            compileOnly("me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0")
        }
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.encoding = "UTF-8"

        // The Minecraft launcher currently installs Java 8 for users, so your mod probably wants to target Java 8 too
        // JDK 9 introduced a new way of specifying this that will make sure no newer classes or methods are used.
        // We'll use that if it's available, but otherwise we'll use the older option.
        if (modern_source_support) {
            it.options.release.set(Integer.parseInt(targetVersion.getMajorVersion()))
        }
    }

    gradle.projectsEvaluated {
        tasks.withType(Javadoc).configureEach {
            exclude "**/*Gui.java"
            exclude "${classPath}/config/**"
            exclude "${classPath}/integrations/**"
        }
    }

    def copyDir = "$compileJava.temporaryDir/replaced"
    tasks.register('processSource', Sync) {
        // This will ensure that this task is redone when the properties change.
        inputs.property "modName", "${mod_name}"
        inputs.property "versionId", "${versionId}"
        inputs.property "versionType", "${deploymentType}"
        inputs.property "versionLabel", "${versionLabel}"
        inputs.property "mcVersion", "${mc_version}"
        inputs.property "mcProtocol", "${mc_protocol}"
        inputs.property "isDevState", "${isDevState}"
        inputs.property "isVerboseState", "${isVerboseState}"

        from sourceSets.main.java
        filter(ReplaceTokens, tokens: [
                MOD_NAME    : mod_name,
                VERSION_ID  : "${baseVersionLabel}".toString(),
                VERSION_TYPE: deploymentType,
                MC_VERSION  : mc_version,
                MC_PROTOCOL : mc_protocol,
                IS_DEV      : isDevState,
                IS_VERBOSE  : isVerboseState
        ])
        into copyDir
    }

    compileJava {
        source = processSource.outputs

        if (isLegacy) {
            doLast {
                getLogger().info("Processing source via RetroLambda...")
                if (sourceVersion >= JavaVersion.VERSION_12) {
                    getLogger().warn("WARNING: Only Java 11 and below are supported with RetroLambda processing.")
                }
                var retrolambaJar = new URL("https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/2.5.7/retrolambda-2.5.7.jar")
                var retrolambdaFile = new File("${rootProject.buildDir}/retrolambda/retrolambda.jar")
                if (!retrolambdaFile.exists()) {
                    retrolambdaFile.getParentFile().mkdirs()
                    try (InputStream is = retrolambaJar.openStream()) {
                        Files.copy(is, retrolambdaFile.toPath())
                    }
                }
                var classpath = project.sourceSets.main.runtimeClasspath
                var classpathString = classpath.files.collect { it.absolutePath }.join(File.pathSeparator)
                var javahome = currentJvm.getJavaHome().getAbsolutePath()
                var javaexe = javahome + File.separator + "bin" + File.separator + "java"
                if (System.getProperty("os.name").toLowerCase().contains("win") && !System.getProperty("os.name").toLowerCase().contains("darwin")) {
                    javaexe += ".exe"
                }
                var destDir = compileJava.destinationDirectory.getAsFile().getOrNull()
                var processBuilder = new ProcessBuilder(
                        javaexe,
                        "-Dretrolambda.inputDir=${destDir.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.classpath=${classpathString.replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.defaultMethods=true",
                        "-Dretrolambda.bytecodeVersion=51",
                        "-javaagent:${retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-jar",
                        retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ "),
                )
                var outputLog = new File("${rootProject.buildDir}/retrolambda/${project.path.replace(":", "_")}-output.log")
                processBuilder.redirectOutput(outputLog)
                processBuilder.redirectError(outputLog)
                var process = processBuilder.start()
                process.waitFor()
                if (process.exitValue() != 0) {
                    throw new GradleException("RetroLambda failed with exit code " + process.exitValue())
                } else {
                    getLogger().info("Source processing via RetroLambda completed successfully!")
                }
            }
        }
    }
}

forgix {
    group = rootProject.group
    mergedJarName = "${ext_fileFormat}.jar"
    outputDir = "build/libs"

    forge {
        jarLocation = "build/libs/${ext_fileFormat}-forge.jar"
    }

    fabric {
        jarLocation = "build/libs/${ext_fileFormat}-fabric.jar"
    }
}
