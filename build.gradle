import org.apache.tools.ant.filters.ReplaceTokens

import java.nio.file.Files

plugins {
    id 'xyz.wagyourtail.unimined' version '0.3.4-SNAPSHOT' apply false
    id "io.github.pacifistmc.forgix" version "1.2.6"
}

def ext_versionInfoLabel = "${rootProject.deploymentType.equalsIgnoreCase("release") ? "" : "-${rootProject.versionLabel}"}"
def ext_baseVersionLabel = "${rootProject.versionId + ext_versionInfoLabel.replaceAll("\\s", ".")}".toLowerCase()
def ext_classPath = "${rootProject.group}".replace(".", "/") + "/${mod_name}".toLowerCase()

def ext_versionFormat = "${ext_baseVersionLabel + "+" + mc_version}"
def ext_fileFormat = "${rootProject.mod_name}-${ext_versionFormat}"

int ext_protocol = "${mc_protocol}".toInteger()
boolean ext_isLegacy = "${isLegacy}".toBoolean()
boolean ext_isJarMod = "${isJarMod}".toBoolean()

subprojects {
    apply plugin: 'java'
    apply plugin: 'xyz.wagyourtail.unimined'

    ext {
        versionInfoLabel = "${ext_versionInfoLabel}"
        baseVersionLabel = "${ext_baseVersionLabel}"
        classPath = "${ext_classPath}"
        versionFormat = "${ext_versionFormat}"
        fileFormat = "${ext_fileFormat}"
        protocol = ext_protocol
        isLegacy = ext_isLegacy
        isJarMod = ext_isJarMod
    }

    version = "${versionFormat}"
    group = rootProject.group
    archivesBaseName = "${mod_name}"

    JavaVersion targetVersion = JavaVersion.VERSION_1_8

    sourceCompatibility = targetVersion
    targetCompatibility = targetVersion

    java {
        withSourcesJar()
    }

    unimined {
        // debug, puts some things in build/unimined instead of ~/.gradle/caches/unimined
        // I recommend you leave this off until unimined is stable
        useGlobalCache = false
    }

    minecraft {
        if (isLegacy) {
            clientSourceSets = [sourceSets.main]
        }
        mcRemapper.tinyRemapperConf = {
            // most mcp mappings (except older format) dont include field desc
            ignoreFieldDesc(true)
            // this also fixes some issues with them, as it tells tiny remapper to try harder to resolve conflicts
            ignoreConflicts(true)
        }
    }

    repositories {
        flatDir {
            dirs "$rootDir/libs"
        }
        mavenCentral()
        maven {
            name = "Forge"
            url = "https://maven.minecraftforge.net/"
            metadataSources {
                artifact()
            }
        }
        maven {
            name = 'Fabric'
            url = "https://maven.fabricmc.net/"
        }
        maven {
            name = "Legacy Fabric"
            url = "https://maven.legacyfabric.net/"
        }
        // OSS Mavens
        maven { url "https://s01.oss.sonatype.org/content/repositories/releases" }
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots" }
        // HypherionMC Mavens
        maven { url "https://maven.firstdarkdev.xyz/releases" }
        maven { url "https://maven.firstdarkdev.xyz/snapshots" }
        // Mod Integration Mavens
        maven {
            name = "CurseForge"
            url = "https://cursemaven.com"
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
        maven {
            name = 'TerraformersMC'
            url = 'https://maven.terraformersmc.com/releases/'
        }
        ivy {
            name = "ReplayMod"
            url = "https://minio.replaymod.com/replaymod/"
            patternLayout { artifact("[artifact]-[revision](-[classifier])(.[ext])") }
            metadataSources { artifact() }
            content { includeGroup("com.replaymod") }
        }
    }

    dependencies {
        minecraft "net.minecraft:minecraft:${rootProject.mc_version}"
        // If a Legacy Build or below 1.14.4, use MCP Data; otherwise use mojmaps
        if (isLegacy || protocol < 498) {
            if (isJarMod) {
                mappings "local_mod:mcp:${mc_mappings}@zip"
            } else if (!isLegacy) {
                if (protocol >= 340) {
                    mappings "de.oceanlabs.mcp:mcp_config:${rootProject.mc_version}@zip"
                } else {
                    mappings "de.oceanlabs.mcp:mcp:${rootProject.mc_version}:srg@zip"
                }
                mappings "de.oceanlabs.mcp:mcp_stable:${rootProject.mc_mappings}@zip"
            } else {
                mappings "net.minecraftforge:forge:${rootProject.mc_version}-${rootProject.forge_version}:src@zip"
            }
        } else {
            mappings "net.minecraft:minecraft:${rootProject.mc_version}:client-mappings"
        }

        // Only use Intermediaries on Versions that support it
        if ((isLegacy && protocol >= 39) || !isLegacy) {
            mappings "${rootProject.fabric_group}:intermediary:${rootProject.mc_version}:v2"
        }
    }

    tasks.withType(JavaCompile).tap {
        configureEach {
            options.encoding = "UTF-8"

            // The Minecraft launcher currently installs Java 8 for users, so your mod probably wants to target Java 8 too
            // JDK 9 introduced a new way of specifying this that will make sure no newer classes or methods are used.
            // We'll use that if it's available, but otherwise we'll use the older option.
            if (JavaVersion.current().isJava9Compatible()) {
                it.options.release.set(Integer.parseInt(targetVersion.getMajorVersion()))
            }
        }
    }

    gradle.projectsEvaluated {
        tasks.withType(Javadoc).tap {
            configureEach {
                exclude "${classPath}/config/category/**"
                exclude "${classPath}/config/element/**"
                exclude "${classPath}/config/gui/**"
                exclude "${classPath}/integrations/**"
            }
        }
    }

    def copyDir = "$compileJava.temporaryDir/replaced"
    tasks.register('processSource', Sync) {
        // This will ensure that this task is redone when the properties change.
        inputs.property "modName", "${mod_name}"
        inputs.property "versionId", "${versionId}"
        inputs.property "versionType", "${deploymentType}"
        inputs.property "versionLabel", "${versionLabel}"
        inputs.property "mcVersion", "${mc_version}"
        inputs.property "mcProtocol", "${mc_protocol}"

        from sourceSets.main.java
        filter(ReplaceTokens, tokens: [
                MOD_NAME    : mod_name,
                VERSION_ID  : "${baseVersionLabel}".toString(),
                VERSION_TYPE: deploymentType,
                MC_VERSION  : mc_version,
                MC_PROTOCOL : mc_protocol
        ])
        into copyDir
    }

    compileJava {
        source = processSource.outputs

        if (isLegacy) {
            doLast {
                var retrolambaJar = new URL("https://oss.sonatype.org/content/groups/public/net/orfjackal/retrolambda/retrolambda/2.5.7/retrolambda-2.5.7.jar")
                var retrolambdaFile = new File("${rootProject.buildDir}/retrolambda/retrolambda.jar")
                if (!retrolambdaFile.exists()) {
                    retrolambdaFile.getParentFile().mkdirs()
                    try (InputStream is = retrolambaJar.openStream()) {
                        Files.copy(is, retrolambdaFile.toPath())
                    }
                }
                var classpath = project.sourceSets.main.runtimeClasspath
                var classpathString = classpath.files.collect { it.absolutePath }.join(File.pathSeparator)
                var javahome = System.getProperty("java.home")
                var javaexe = javahome + File.separator + "bin" + File.separator + "java"
                if (System.getProperty("os.name").toLowerCase().contains("win") && !System.getProperty("os.name").toLowerCase().contains("darwin")) {
                    javaexe += ".exe"
                }
                var processBuilder = new ProcessBuilder(
                        javaexe,
                        "-Dretrolambda.inputDir=${compileJava.destinationDirectory.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.classpath=${classpathString.replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-Dretrolambda.defaultMethods=true",
                        "-Dretrolambda.bytecodeVersion=51",
                        "-javaagent:${retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ ")}",
                        "-jar",
                        retrolambdaFile.absolutePath.toString().replace("\\", "\\\\").replace(" ", "\\ "),
                )
                var outputLog = new File("${rootProject.buildDir}/retrolambda/${project.path.replace(":", "_")}output.log")
                processBuilder.redirectOutput(outputLog)
                processBuilder.redirectError(outputLog)
                var process = processBuilder.start()
                process.waitFor()
                if (process.exitValue() != 0) {
                    throw new GradleException("RetroLambda failed with exit code " + process.exitValue())
                }
            }
        }
    }
}

forgix {
    group = rootProject.group
    mergedJarName = "${ext_fileFormat}-universal.jar"
    outputDir = "build/libs"

    forge {
        jarLocation = "build/libs/${ext_fileFormat}-forge.jar"
    }

    fabric {
        jarLocation = "build/libs/${ext_fileFormat}-fabric.jar"
    }
}
